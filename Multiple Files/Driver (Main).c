#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  UltronFront,    sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  EncoderFront,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  EncoderBack,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, Armangle,       sensorQuadEncoder)
#pragma config(Motor,  port1,           Claw,          tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port2,           backLeft,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           Launcher4,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           frontLeft,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           Launcher2,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           Launcher,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           Launcher3,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port9,           backRight,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          Claw2,         tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"
#include "Variables.c"
#include "User Functions.c"
#include "Pre-Autonomous.c"
#include "Autonomous.c"

task usercontrol()
{
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 15; //Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	while(1)
	{
		if(abs(vexRT[Ch3]) > threshold) Y1 = vexRT[Ch3]; //Create "deadzone" for Y1/Ch3
		else Y1 = 0;
		if(abs(vexRT[Ch4]) > threshold) X1 = vexRT[Ch4]; //Create "deadzone" for X1/Ch4
		else X1 = 0;
		if(abs(vexRT[Ch1]) > threshold) X2 = vexRT[Ch1]; //Create "deadzone" for X2/Ch1
		else X2 = 0;
		motor[frontRight] = Y1 - X2 - X1; //Remote Control/Driving Commands
		motor[backRight] =  Y1 - X2 + X1;
		motor[frontLeft] = Y1 + X2 + X1;
		motor[backLeft] =  Y1 + X2 - X1;

		pot_val = SensorValue[Armangle];
		ultron_front_val = SensorValue[UltronFront];//sets the values of the ultrasonic sensors to their own variables
		getDriveEncoders();

		if (vexRT[Btn7UXmtr2] == 1)pre_auton();

		if (vexRT[Btn6D] == 1)
		{
			resetArmEncoder();
			resetDriveEncoder();
			SensorValue[Gyro] = 0;
			newGyroVal = 0;
		}
		if (vexRT[Btn8DXmtr2] == 1) auto_throw = 0;
		if (vexRT[Btn8LXmtr2] == 1) gyroTurn(2, 450);

		if (vexRT[Btn8RXmtr2] == 1)
		{
			resetArmEncoder();
			auto_throw = cube;
			clawOC(50);
			wait1Msec(5);
		}
		else if (vexRT[Btn8DXmtr2] == 1)
		{
			auto_throw = 0;
			wait1Msec(5);
		}

		if (auto_throw != 0 && pot_val > 83)
		{
			clawOC(-127);
			pot_val = SensorValue[Armangle];
		}

		if (auto_throw != 0 && pot_val < 95)
		{
			launchval = -127;
			pot_val = SensorValue[Armangle];
		}
		else if (auto_throw != 0 && pot_val >= 95)
		{
			launchval = 0;
			clawval = 0;
			auto_throw = 0;
			pot_val = SensorValue[Armangle];
		}
		else if (auto_throw == 0)
		{
			if (abs(vexRT[Ch3Xmtr2]) > threshold)
			{
				launchval = -(vexRT[Ch3Xmtr2]);//sets the speed of the arm from the left joystick on the 2nd controller
			}
			else launchval = 0;
			if (abs(vexRT[Ch2Xmtr2]) > threshold) clawval = vexRT[Ch2Xmtr2];
			else clawval = 0;
			clawOC(clawval);
		}
		launch(launchval);//actually moves the launcher motors to the set speed

		if ((nSysTime % 100) == 0)
		{
			clearLCDLine(0);
			clearLCDLine(1);

			displayLCDNumber(1, 0, ultron_front_val);//prints the value of the front ultrasonic sensor to the LCD Screen
			displayNextLCDString(" inches");

			displayLCDNumber(0, 0, SensorValue[Gyro]);
			displayNextLCDString(" ");
			displayNextLCDNumber(encoder_avg_val);
			displayNextLCDString(" ");
			displayNextLCDNumber(pot_val);//displays the value of the potentiometer/angle of the arm to the LCD Screen
		}
	}
}
